---
import { getCollection, render } from 'astro:content';
import PageLayout from '~/layouts/PageLayout.astro';
import { Icon } from 'astro-icon/components';
// 1. Generate a new path for every collection entry
export async function getStaticPaths() {
  const posts = await getCollection('blog');
  return posts.map((post) => ({
    params: { id: post.id },
    props: { post },
  }));
}
// 2. For your template, you can get the entry directly from the prop
const { post } = Astro.props;
const { Content } = await render(post);
---

<PageLayout>
  <h1 class="text-3xl font-bold">{post.data.title}</h1>
  <div
    class="prose dark:prose-invert
  prose-h1:font-bold prose-h1:text-xl
  prose-a:text-blue-700
  prose-a:dark:text-blue-200
  prose-p:text-justify prose-img:rounded-xl
  prose-headings:underline"
  >
    <Content />
  </div>
</PageLayout>

<script is:inline>
  /** Attaches links to headings in the document,
   *  allowing sharing of sections easily */
  function addHeadingLinks() {
    let headings = Array.from(document.querySelectorAll('h2, h3, h4, h5, h6'));
    for (let heading of headings) {
      heading.classList.add('group');
      let link = document.createElement('a');
      link.innerText = '#';
      link.className = 'heading-link hidden group-hover:inline-block ml-2';
      link.href = '#' + heading.id;
      link.ariaHidden = 'true';
      heading.appendChild(link);
    }
  }
  addHeadingLinks();

  /** Create a progress indicator
   *  at the top */
  function createProgressBar() {
    // Create the main container div
    const progressContainer = document.createElement('div');
    progressContainer.className = 'fixed top-0 left-0 z-50 h-1 w-full bg-gray-200 dark:bg-gray-700';

    // Create the progress bar div
    const progressBar = document.createElement('div');
    progressBar.className = 'h-1 w-0 bg-blue-500 dark:bg-blue-200';
    progressBar.id = 'myBar';

    // Append the progress bar to the progress container
    progressContainer.appendChild(progressBar);

    // Append the progress container to the document body
    document.body.appendChild(progressContainer);
  }
  createProgressBar();

  /** Update the scroll progress bar when user scrolls */
  function updateScrollProgress() {
    const winScroll = document.body.scrollTop || document.documentElement.scrollTop;
    const height = document.documentElement.scrollHeight - document.documentElement.clientHeight;
    const scrolled = (winScroll / height) * 100;
    const myBar = document.getElementById('myBar');
    if (myBar) {
      myBar.style.width = scrolled + '%';
    }
  }
  document.addEventListener('scroll', updateScrollProgress);

  /** Scrolls the document to the top when
   * the "Back to Top" button is clicked. */
  function backToTop() {
    document.querySelector('#back-to-top')?.addEventListener('click', () => {
      document.body.scrollTop = 0; // For Safari
      document.documentElement.scrollTop = 0; // For Chrome, Firefox, IE and Opera
    });
  }
  backToTop();

  /** Add language labels and copy buttons to code blocks */
  function enhanceCodeBlocks() {
    const codeBlocks = document.querySelectorAll('pre');

    codeBlocks.forEach((pre) => {
      // Create container for the code block with relative positioning
      const container = document.createElement('div');
      container.className = 'relative group';
      pre.parentNode.insertBefore(container, pre);
      container.appendChild(pre);

      // Get the code element and its language
      const code = pre.querySelector('code');
      if (!code) return;

      // Get language from pre.dataset.language
      let language = pre.dataset.language || 'text';

      // Add language label
      const languageLabel = document.createElement('div');
      languageLabel.className =
        'dark absolute top-0 right-0 text-muted text-xs m-2 p-2 rounded-sm group-hover:opacity-0 transition-opacity';
      languageLabel.textContent = language;
      container.appendChild(languageLabel);

      // Add copy button
      const copyButton = document.createElement('button');
      copyButton.className =
        'dark absolute top-0 right-0 m-1 p-2 text-muted text-xs rounded-sm opacity-0 group-hover:opacity-100 transition-all duration-300 ease-in-out hover:cursor-pointer border border-transparent hover:border-muted';

      // Use Tabler icon for copy
      copyButton.innerHTML = `
        <svg  xmlns="http://www.w3.org/2000/svg"  width="24"  height="24"  viewBox="0 0 24 24"  fill="none"  stroke="currentColor"  stroke-width="2"  stroke-linecap="round"  stroke-linejoin="round"  class="icon icon-tabler icons-tabler-outline icon-tabler-copy"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M7 7m0 2.667a2.667 2.667 0 0 1 2.667 -2.667h8.666a2.667 2.667 0 0 1 2.667 2.667v8.666a2.667 2.667 0 0 1 -2.667 2.667h-8.666a2.667 2.667 0 0 1 -2.667 -2.667z" /><path d="M4.012 16.737a2.005 2.005 0 0 1 -1.012 -1.737v-10c0 -1.1 .9 -2 2 -2h10c.75 0 1.158 .385 1.5 1" /></svg>
      `;
      copyButton.title = 'Copy code';
      container.appendChild(copyButton);

      // Add click event to copy button
      copyButton.addEventListener('click', () => {
        const codeText = code.textContent;
        const checkmarkIcon = `
        <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="icon icon-tabler icons-tabler-outline icon-tabler-check"><path stroke="none" d="M0 0h24v24H0z" fill="none"/><path d="M5 12l5 5l10 -10" /></svg>
        `;
        const originalContent = copyButton.innerHTML;

        // Check if Clipboard API is available
        if (navigator && navigator.clipboard && navigator.clipboard.writeText) {
          navigator.clipboard
            .writeText(codeText)
            .then(() => {
              // Show checkmark icon with transition
              copyButton.innerHTML = checkmarkIcon;

              // Reset after 2 seconds
              setTimeout(() => {
                copyButton.innerHTML = originalContent;
              }, 2000);
            })
            .catch((err) => {
              console.error('Failed to copy code: ', err);
              fallbackCopyTextToClipboard(codeText, copyButton, checkmarkIcon, originalContent);
            });
        } else {
          // Fallback for browsers that don't support clipboard API
          fallbackCopyTextToClipboard(codeText, copyButton, checkmarkIcon, originalContent);
        }
      });
    });
  }

  /**
   * Fallback method to copy text to clipboard using a temporary textarea element
   */
  function fallbackCopyTextToClipboard(text, button, checkmarkIcon, originalContent) {
    const textArea = document.createElement('textarea');
    textArea.value = text;

    // Make the textarea out of viewport
    textArea.style.position = 'fixed';
    textArea.style.left = '-999999px';
    textArea.style.top = '-999999px';
    document.body.appendChild(textArea);

    textArea.focus();
    textArea.select();

    let successful = false;
    try {
      successful = document.execCommand('copy');
    } catch (err) {
      console.error('Fallback: Oops, unable to copy', err);
    }

    document.body.removeChild(textArea);

    // Update button with checkmark or error indication
    if (button) {
      if (successful) {
        button.innerHTML = checkmarkIcon;
      } else {
        button.innerHTML = `<span>Failed!</span>`;
      }

      // Reset after 2 seconds
      setTimeout(() => {
        button.innerHTML = originalContent;
      }, 2000);
    }
  }

  // Run the code block enhancement after the page loads
  document.addEventListener('DOMContentLoaded', enhanceCodeBlocks);
  // Also run it immediately in case the DOM is already loaded
  if (document.readyState === 'interactive' || document.readyState === 'complete') {
    enhanceCodeBlocks();
  }
</script>
